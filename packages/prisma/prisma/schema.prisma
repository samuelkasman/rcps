generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String               @id @default(cuid())
  email               String               @unique
  createdAt           DateTime             @default(now())
  role                UserRole             @default(USER)
  username            String?
  password            String?
  ingredients         Ingredient[]         @relation("UserIngredients")
  recipes             Recipe[]             @relation("RecipeAuthor")
  connectionsReceived UserConnection[]     @relation("ConnectionReceiver")
  connectionsSent     UserConnection[]     @relation("ConnectionSender")
  favorites           UserFavoriteRecipe[]
}

model UserConnection {
  id         String           @id @default(cuid())
  senderId   String
  receiverId String
  status     ConnectionStatus
  createdAt  DateTime         @default(now())
  receiver   User             @relation("ConnectionReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     User             @relation("ConnectionSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
}

model Ingredient {
  id                 String                @id @default(cuid())
  name               String
  origin             ContentOrigin
  ownerType          IngredientOwner
  ownerUserId        String?
  visibility         Visibility            @default(PRIVATE)
  density            Float?
  createdAt          DateTime              @default(now())
  sourceIngredientId String?
  ownerUser          User?                 @relation("UserIngredients", fields: [ownerUserId], references: [id])
  sourceIngredient   Ingredient?           @relation("IngredientFork", fields: [sourceIngredientId], references: [id])
  forks              Ingredient[]          @relation("IngredientFork")
  nutritions         IngredientNutrition[]
  recipes            RecipeIngredient[]

  @@index([name])
  @@index([visibility])
  @@index([origin])
  @@index([ownerUserId])
}

model Nutrient {
  id               String                @id @default(cuid())
  key              String                @unique
  name             String
  unit             NutrientUnit
  category         NutrientCategory
  rda              Float?
  ingredientValues IngredientNutrition[]
  recipeValues     RecipeNutrition[]
}

model IngredientNutrition {
  ingredientId  String
  nutrientId    String
  amountPer100g Float
  ingredient    Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  nutrient      Nutrient   @relation(fields: [nutrientId], references: [id], onDelete: Cascade)

  @@id([ingredientId, nutrientId])
}

model Recipe {
  id             String               @id @default(cuid())
  title          String
  slug           String               @unique
  description    String?
  instructions   String
  servings       Int
  prepMinutes    Int?
  cookMinutes    Int?
  status         RecipeStatus         @default(DRAFT)
  visibility     Visibility           @default(PRIVATE)
  origin         ContentOrigin
  createdAt      DateTime             @default(now())
  authorId       String?
  sourceRecipeId String?
  author         User?                @relation("RecipeAuthor", fields: [authorId], references: [id])
  sourceRecipe   Recipe?              @relation("RecipeFork", fields: [sourceRecipeId], references: [id])
  forks          Recipe[]             @relation("RecipeFork")
  images         RecipeImage[]
  ingredients    RecipeIngredient[]
  nutritions     RecipeNutrition[]
  tags           RecipeTag[]
  favorites      UserFavoriteRecipe[]

  @@index([visibility])
  @@index([origin])
  @@index([status])
}

model RecipeIngredient {
  recipeId     String
  ingredientId String
  quantity     Float
  unit         MeasurementUnit
  orderIndex   Int?
  ingredient   Ingredient      @relation(fields: [ingredientId], references: [id])
  recipe       Recipe          @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@id([recipeId, ingredientId])
}

model RecipeNutrition {
  recipeId         String
  nutrientId       String
  amountTotal      Float
  amountPerServing Float
  nutrient         Nutrient @relation(fields: [nutrientId], references: [id])
  recipe           Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@id([recipeId, nutrientId])
}

model Tag {
  id      String      @id @default(cuid())
  name    String      @unique
  type    TagType
  recipes RecipeTag[]
}

model RecipeTag {
  recipeId String
  tagId    String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  tag      Tag    @relation(fields: [tagId], references: [id])

  @@id([recipeId, tagId])
}

model RecipeImage {
  id       String @id @default(cuid())
  recipeId String
  url      String
  order    Int?
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
}

model UserFavoriteRecipe {
  userId    String
  recipeId  String
  createdAt DateTime @default(now())
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, recipeId])
}

enum UserRole {
  USER
  ADMIN
}

enum Visibility {
  PRIVATE
  FRIENDS
  PUBLIC
}

enum ContentOrigin {
  BASE
  USER
}

enum IngredientOwner {
  SYSTEM
  USER
}

enum RecipeStatus {
  DRAFT
  PUBLISHED
}

enum MeasurementUnit {
  G
  ML
}

enum NutrientUnit {
  G
  MG
  UG
  KCAL
}

enum NutrientCategory {
  MACRO
  MICRO
  ENERGY
}

enum TagType {
  MANUAL
  DERIVED
  SYSTEM
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  BLOCKED
}
